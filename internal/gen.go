package internal

import (
	"bytes"
	"fmt"
	"go/format"
	"text/template"
)

func GenOutSrcFromParsed(packName string, packImports map[string]string, parsedInterfaces []Interface) []byte {
	return createGenModule(packName, packImports, parsedInterfaces).genSrc()
}

type genModule struct {
	GenComment string
	Name       string
	Imports    []string
	Structs    []genStruct
}

type genStruct struct {
	Name    string
	Fields  []genParam
	Methods []genMethod
}

type genMethod struct {
	RecvName     string
	StructName   string
	Name         string
	Params       []genParam
	Res          []genParam
	ReturnFields []genReturnField
}

type genParam struct {
	Name string
	Type string
}

type genReturnField struct {
	Recv string
	Name string
}

// createGenModule: packImports {'packAlias': 'packAlias "path/to/package"'}
func createGenModule(packName string, packImports map[string]string, parsedInterfaces []Interface) genModule {
	structs := make([]genStruct, 0)
	needImports := make([]string, 0)
	for _, parsedInterface := range parsedInterfaces {
		structName := "Stub" + parsedInterface.Name
		recv := "s"
		structFields := make([]genParam, 0)
		methods := make([]genMethod, 0)
		for _, parsedMethod := range parsedInterface.Methods {
			params := make([]genParam, 0)
			for _, parsedParams := range parsedMethod.Params {
				needImports = updatedImports(parsedParams.Type.Package, needImports, packImports)
				paramName := parsedParams.Name
				if paramName == "" {
					paramName = "_"
				}
				params = append(params, genParam{
					Name: paramName,
					Type: parsedParams.Type.String(),
				})
			}
			res := make([]genParam, 0)
			returnFields := make([]genReturnField, 0)
			for i, parsedRes := range parsedMethod.Res {
				needImports = updatedImports(parsedRes.Type.Package, needImports, packImports)
				returnFieldName := fmt.Sprintf("%sRes%d", parsedMethod.Name, i)
				structFields = append(structFields, genParam{
					Name: returnFieldName,
					Type: parsedRes.Type.String(),
				})
				res = append(res, genParam{
					Name: parsedRes.Name,
					Type: parsedRes.Type.String(),
				})
				returnFields = append(returnFields, genReturnField{
					Recv: recv,
					Name: returnFieldName,
				})
			}
			methods = append(methods, genMethod{
				RecvName:     recv,
				StructName:   structName,
				Name:         parsedMethod.Name,
				Params:       params,
				Res:          res,
				ReturnFields: returnFields,
			})
		}
		structs = append(structs, genStruct{
			Name:    structName,
			Fields:  structFields,
			Methods: methods,
		})
	}
	return genModule{
		GenComment: "// Code generated by stubgen; DO NOT EDIT.",
		Name:       packName,
		Imports:    needImports,
		Structs:    structs,
	}
}

func updatedImports(typePackage string, imports []string, packImports map[string]string) []string {
	if typePackage != "" {
		imp, ok := packImports[typePackage]
		if ok {
			return append(imports, imp)
		}
	}
	return imports
}

func (g genModule) genSrc() []byte {
	buf := new(bytes.Buffer)
	err := moduleTemplate.Execute(buf, g)
	if err != nil {
		panic(fmt.Errorf("error filling template: %w", err))
	}
	pretty, err := format.Source(buf.Bytes())
	if err != nil {
		panic(fmt.Errorf("error formatting stubs code: %w", err))
	}
	return bytes.Trim(pretty, "\n")
}

const moduleTemplateString = `
{{.GenComment}}

package {{.Name}}

{{if .Imports}}
import (
{{range .Imports}}    {{.}}
{{end}}
)
{{end}}

{{range .Structs}}
type {{.Name}} struct {
	{{range .Fields}} {{.Name}} {{.Type}}
	{{end}}
}
{{range .Methods}} 
func ({{.RecvName}} {{.StructName}}) {{.Name}} ({{range .Params}}{{.Name}} {{.Type}}, {{end}}) ({{range .Res}}{{.Name}} {{.Type}}, {{end}}){
	return {{range $i, $returnField := .ReturnFields}} {{if $i}},{{end}} {{.Recv}}.{{.Name}}{{end}}
}
{{end}}
{{end}}
`

var moduleTemplate = template.Must(template.New("stub template").Parse(moduleTemplateString))
